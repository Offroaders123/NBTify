{
  "version": 3,
  "sources": ["modules/encoding.js", "modules/tags.js", "modules/Reader.js", "modules/parse.js", "modules/Writer.js", "modules/write.js", "index.js"],
  "sourcesContent": ["export function decode(array){\n  const string = new TextDecoder(\"utf-8\").decode(array);\n  return string;\n}\n\nexport function encode(string){\n  const array = new TextEncoder().encode(string);\n  return array;\n}", "/* A mapping from type names to NBT type numbers. */\nexport const tags = {\n  end: 0,\n  byte: 1,\n  short: 2,\n  int: 3,\n  long: 4,\n  float: 5,\n  double: 6,\n  byteArray: 7,\n  string: 8,\n  list: 9,\n  compound: 10,\n  intArray: 11,\n  longArray: 12\n};\n\n/* A mapping from NBT type numbers to type names. */\nexport const names = Object.fromEntries(Object.entries(tags).map(array => array.reverse()));", "import { decode } from \"./encoding.js\";\nimport { tags, names } from \"./tags.js\";\n\n/*\n  In addition to the named writing methods documented below,\n  the same methods are indexed by the NBT type number as well,\n  as shown in the example below.\n*/\nexport default class Reader {\n  constructor(buffer,endian){\n    if (!buffer) throw new Error(`Argument \"buffer\" is falsy`);\n\n    /*\n      The current location in the buffer. Can be freely\n      changed within the bounds of the buffer.\n    */\n    this.offset = 0;\n\n    this.endian = endian;\n\n    const arrayView = new Uint8Array(buffer);\n    const dataView = new DataView(buffer);\n\n    const read = (dataType,size) => {\n      /* This is where the endian parameter comes into play */\n      const value = dataView[`get${dataType}`](this.offset,(this.endian === \"little\"));\n      this.offset += size;\n      return value;\n    };\n\n    /* read byte */\n    this.byte = read.bind(this,\"Int8\",1);\n\n    /* read unsigned byte */\n    this.ubyte = read.bind(this,\"Uint8\",1);\n\n    /* read signed 16-bit short */\n    this.short = read.bind(this,\"Int16\",2);\n\n    /* read signed 32-bit integer */\n    this.int = read.bind(this,\"Int32\",4);\n\n    /* read signed 32-bit float */\n    this.float = read.bind(this,\"Float32\",4);\n\n    /* read signed 64-bit float */\n    this.double = read.bind(this,\"Float64\",8);\n\n    /*\n      As JavaScript does not not natively support 64-bit\n      integers, the value is returned as an array of two\n      32-bit integers, the upper and the lower.\n    */\n    this.long = () => [this.int(),this.int()];\n\n    /* read array */\n    this.byteArray = () => {\n      const length = this.int();\n      const bytes = [];\n      for (let i = 0; i < length; i++) bytes.push(this.byte());\n      return bytes;\n    };\n\n    /* read array of 32-bit ints */\n    this.intArray = () => {\n      const length = this.int();\n      const ints = [];\n      for (let i = 0; i < length; i++) ints.push(this.int());\n      return ints;\n    };\n\n    /*\n      As JavaScript does not not natively support 64-bit\n      integers, the value is returned as an array of arrays of two\n      32-bit integers, the upper and the lower.\n    */\n    /* read array of 64-bit ints */\n    this.longArray = () => {\n      const length = this.int();\n      const longs = [];\n      for (let i = 0; i < length; i++) longs.push(this.long());\n      return longs;\n    };\n\n    /* read string */\n    this.string = () => {\n      const length = this.short();\n      const slice = arrayView.slice(this.offset,this.offset + length);\n      this.offset += length;\n      return decode(slice);\n    };\n\n    this.list = () => {\n      const type = this.byte();\n      const length = this.int();\n      const values = [];\n      for (let i = 0; i < length; i++) values.push(this[type]());\n      return {\n        type: names[type],\n        value: values\n      };\n    };\n\n    this.compound = () => {\n      const values = {};\n      while (true){\n        const type = this.byte();\n        if (type === tags.end) break;\n        const name = this.string();\n        const value = this[type]();\n        values[name] = {\n          type: names[type],\n          value\n        };\n      }\n      return values;\n    };\n\n    for (let type in names){\n      if (names.hasOwnProperty(type)) this[type] = this[names[type]];\n    }\n  }\n}", "import Reader from \"./Reader.js\";\nimport { tags } from \"./tags.js\";\n\n/*\n  This accepts both gzipped and uncompressd NBT archives.\n  If the archive is uncompressed, the callback will be\n  called directly from this method. For gzipped files, the\n  callback is async.\n\n  For use in the browser, window.zlib must be defined to decode\n  compressed archives. It will be passed a Buffer if the type is\n  available, or an Uint8Array otherwise.\n*/\nexport default function parse(data,{ endian = \"big\" } = {}){\n  if (!data) throw new Error(`Argument \"data\" is falsy`);\n\n  if (hasGzipHeader(data)) data = new Zlib.Gunzip(new Uint8Array(data)).decompress().buffer;\n\n  /* Remove the Bedrock level header bytes if they are present in the data */\n  if (hasBedrockLevelHeader(data)) data = data.slice(8);\n\n  /*\n    The \"endian\" parameter determines how the data should be parsed. Java NBT uses the\n    \"big\" endian format (the default for the function), and Bedrock NBT uses \"little\" endian.\n  */\n  const reader = new Reader(data,endian);\n\n  const type = reader.byte();\n  if (type !== tags.compound) throw new Error(\"Top tag must be a compound\");\n\n  const result = {\n    name: reader.string(),\n    value: reader.compound()\n  };\n  return result;\n}\n\nfunction hasBedrockLevelHeader(data){\n  const header = new Uint8Array(data.slice(0,4));\n  const result = (header[1] === 0 && header[2] === 0 && header[3] === 0);\n  return result;\n}\n\nfunction hasGzipHeader(data){\n  const header = new Uint8Array(data.slice(0,2));\n  const result = (header.length === 2 && header[0] === 31 && header[1] === 139);\n  return result;\n}", "import { encode } from \"./encoding.js\";\nimport { tags, names } from \"./tags.js\";\n\nexport default class Writer {\n  constructor(endian){\n    /* Will be resized (x2) on write if necessary. */\n    let buffer = new ArrayBuffer(1024);\n\n    /* These are recreated when the buffer is. */\n    let dataView = new DataView(buffer);\n    let arrayView = new Uint8Array(buffer);\n\n    /*\n      The location in the buffer where bytes are written or read.\n      This increases after every write, but can be freely changed.\n      The buffer will be resized when necessary.\n    */\n    this.offset = 0;\n\n    this.endian = endian;\n\n    /*\n      Ensures that the buffer is large enough to write `size`\n      bytes at the current `this.offset`.\n    */\n    const accommodate = size => {\n      const requiredLength = this.offset + size;\n      if (buffer.byteLength >= requiredLength) return;\n\n      let newLength = buffer.byteLength;\n      while (newLength < requiredLength) newLength *= 2;\n\n      const newBuffer = new ArrayBuffer(newLength);\n      const newArrayView = new Uint8Array(newBuffer);\n      newArrayView.set(arrayView);\n\n      /*\n        If there's a gap between the end of the old buffer\n        and the start of the new one, we need to zero it out\n      */\n      if (this.offset > buffer.byteLength) newArrayView.fill(0,buffer.byteLength,this.offset);\n\n      buffer = newBuffer;\n      dataView = new DataView(newBuffer);\n      arrayView = newArrayView;\n    };\n\n    const write = (dataType,size,value) => {\n      accommodate(size);\n      /* This is where the endian parameter comes into play */\n      dataView[`set${dataType}`](this.offset,value,(this.endian === \"little\"));\n      this.offset += size;\n      return this;\n    }\n\n    /*\n      Returns the writen data as a slice from the internal\n      buffer, cutting off any padding at the end.\n    */\n    this.getData = () => {\n      accommodate(0); /* make sure the offset is inside the buffer */\n      return buffer.slice(0,this.offset);\n    };\n\n    /* a signed byte */\n    this.byte = write.bind(this,\"Int8\",1);\n\n    /* an unsigned byte */\n    this.ubyte = write.bind(this,\"Uint8\",1);\n\n    /* a signed 16-bit integer */\n    this.short = write.bind(this,\"Int16\",2);\n\n    /* a signed 32-bit integer */\n    this.int = write.bind(this,\"Int32\",4);\n\n    /* a signed 32-bit float */\n    this.float = write.bind(this,\"Float32\",4);\n\n    /* a signed 64-bit float */\n    this.double = write.bind(this,\"Float64\",8);\n\n    /*\n      As JavaScript does not support 64-bit integers natively,\n      this method takes an array of two 32-bit integers that\n      make up the upper and lower halves of the long.\n    */\n    this.long = value => {\n      this.int(value[0]);\n      this.int(value[1]);\n      return this;\n    };\n\n    this.byteArray = value => {\n      this.int(value.length);\n      accommodate(value.length);\n      arrayView.set(value,this.offset);\n      this.offset += value.length;\n      return this;\n    };\n\n    this.intArray = value => {\n      this.int(value.length);\n      for (let i = 0; i < value.length; i++) this.int(value[i]);\n      return this;\n    };\n\n    this.longArray = value => {\n      this.int(value.length);\n      for (let i = 0; i > value.length; i++) this.long(value[i]);\n      return this;\n    };\n\n    this.string = value => {\n      const bytes = encode(value);\n      this.short(bytes.length);\n      accommodate(bytes.length);\n      arrayView.set(bytes,this.offset);\n      this.offset += bytes.length;\n      return this;\n    };\n\n    this.list = value => {\n      this.byte(tags[value.type]);\n      this.int(value.value.length);\n      for (let i = 0; i < value.value.length; i++) this[value.type](value.value[i]);\n      return this;\n    };\n\n    this.compound = value => {\n      Object.keys(value).map(key => {\n        this.byte(tags[value[key].type]);\n        this.string(key);\n        this[value[key].type](value[key].value);\n      });\n      this.byte(tags.end);\n      return this;\n    };\n\n    for (let type in names){\n      if (names.hasOwnProperty(type)) this[type] = this[names[type]];\n    }\n  }\n}", "import Writer from \"./Writer.js\";\nimport { tags } from \"./tags.js\";\n\nexport default function write(data,{ endian = \"big\", gzip = false } = {}){\n  if (!data) throw new Error(`Argument \"data\" is falsy`);\n\n  /*\n    The \"endian\" parameter determines how the data should be parsed. Java NBT uses the\n    \"big\" endian format (the default for the function), and Bedrock NBT uses \"little\" endian.\n  */\n  const writer = new Writer(endian);\n\n  writer.byte(tags.compound);\n  writer.string(data.name);\n  writer.compound(data.value);\n\n  const result = writer.getData();\n\n  /* Using GZIP compression while writing NBT data doesn't work as expected at the moment. */\n  return (gzip) ? new Zlib.Gzip(new Uint8Array(result)).compress().buffer : result;\n}", "// ES Module imports\nimport parse from \"./modules/parse.js\";\nimport write from \"./modules/write.js\";\n\nwindow.nbt = { parse, write };"],
  "mappings": "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",
  "names": []
}
