(() => {
  // modules/encoding.js
  function decode(array) {
    const string = new TextDecoder("utf-8").decode(array);
    return string;
  }
  function encode(string) {
    const array = new TextEncoder().encode(string);
    return array;
  }

  // modules/tags.js
  var tags = {
    end: 0,
    byte: 1,
    short: 2,
    int: 3,
    long: 4,
    float: 5,
    double: 6,
    byteArray: 7,
    string: 8,
    list: 9,
    compound: 10,
    intArray: 11,
    longArray: 12
  };
  var names = Object.fromEntries(Object.entries(tags).map((array) => array.reverse()));

  // modules/Reader.js
  var Reader = class {
    constructor(buffer, endian) {
      if (!buffer)
        throw new Error(`Argument "buffer" is falsy`);
      this.offset = 0;
      this.endian = endian;
      const arrayView = new Uint8Array(buffer);
      const dataView = new DataView(buffer);
      const read = (dataType, size) => {
        const value = dataView[`get${dataType}`](this.offset, this.endian === "little");
        this.offset += size;
        return value;
      };
      this.byte = read.bind(this, "Int8", 1);
      this.ubyte = read.bind(this, "Uint8", 1);
      this.short = read.bind(this, "Int16", 2);
      this.int = read.bind(this, "Int32", 4);
      this.float = read.bind(this, "Float32", 4);
      this.double = read.bind(this, "Float64", 8);
      this.long = () => [this.int(), this.int()];
      this.byteArray = () => {
        const length = this.int();
        const bytes = [];
        for (let i = 0; i < length; i++)
          bytes.push(this.byte());
        return bytes;
      };
      this.intArray = () => {
        const length = this.int();
        const ints = [];
        for (let i = 0; i < length; i++)
          ints.push(this.int());
        return ints;
      };
      this.longArray = () => {
        const length = this.int();
        const longs = [];
        for (let i = 0; i < length; i++)
          longs.push(this.long());
        return longs;
      };
      this.string = () => {
        const length = this.short();
        const slice = arrayView.slice(this.offset, this.offset + length);
        this.offset += length;
        return decode(slice);
      };
      this.list = () => {
        const type = this.byte();
        const length = this.int();
        const values = [];
        for (let i = 0; i < length; i++)
          values.push(this[type]());
        return {
          type: names[type],
          value: values
        };
      };
      this.compound = () => {
        const values = {};
        while (true) {
          const type = this.byte();
          if (type === tags.end)
            break;
          const name = this.string();
          const value = this[type]();
          values[name] = {
            type: names[type],
            value
          };
        }
        return values;
      };
      for (let type in names) {
        if (names.hasOwnProperty(type))
          this[type] = this[names[type]];
      }
    }
  };

  // modules/parse.js
  function parse(data, { endian = "big" } = {}) {
    if (!data)
      throw new Error(`Argument "data" is falsy`);
    if (hasGzipHeader(data))
      data = new Zlib.Gunzip(new Uint8Array(data)).decompress().buffer;
    if (hasBedrockLevelHeader(data))
      data = data.slice(8);
    const reader = new Reader(data, endian);
    const type = reader.byte();
    if (type !== tags.compound)
      throw new Error("Top tag must be a compound");
    const result = {
      name: reader.string(),
      value: reader.compound()
    };
    return result;
  }
  function hasBedrockLevelHeader(data) {
    const header = new Uint8Array(data.slice(0, 4));
    const result = header[1] === 0 && header[2] === 0 && header[3] === 0;
    return result;
  }
  function hasGzipHeader(data) {
    const header = new Uint8Array(data.slice(0, 2));
    const result = header.length === 2 && header[0] === 31 && header[1] === 139;
    return result;
  }

  // modules/Writer.js
  var Writer = class {
    constructor(endian) {
      let buffer = new ArrayBuffer(1024);
      let dataView = new DataView(buffer);
      let arrayView = new Uint8Array(buffer);
      this.offset = 0;
      this.endian = endian;
      const accommodate = (size) => {
        const requiredLength = this.offset + size;
        if (buffer.byteLength >= requiredLength)
          return;
        let newLength = buffer.byteLength;
        while (newLength < requiredLength)
          newLength *= 2;
        const newBuffer = new ArrayBuffer(newLength);
        const newArrayView = new Uint8Array(newBuffer);
        newArrayView.set(arrayView);
        if (this.offset > buffer.byteLength)
          newArrayView.fill(0, buffer.byteLength, this.offset);
        buffer = newBuffer;
        dataView = new DataView(newBuffer);
        arrayView = newArrayView;
      };
      const write2 = (dataType, size, value) => {
        accommodate(size);
        dataView[`set${dataType}`](this.offset, value, this.endian === "little");
        this.offset += size;
        return this;
      };
      this.getData = () => {
        accommodate(0);
        return buffer.slice(0, this.offset);
      };
      this.byte = write2.bind(this, "Int8", 1);
      this.ubyte = write2.bind(this, "Uint8", 1);
      this.short = write2.bind(this, "Int16", 2);
      this.int = write2.bind(this, "Int32", 4);
      this.float = write2.bind(this, "Float32", 4);
      this.double = write2.bind(this, "Float64", 8);
      this.long = (value) => {
        this.int(value[0]);
        this.int(value[1]);
        return this;
      };
      this.byteArray = (value) => {
        this.int(value.length);
        accommodate(value.length);
        arrayView.set(value, this.offset);
        this.offset += value.length;
        return this;
      };
      this.intArray = (value) => {
        this.int(value.length);
        for (let i = 0; i < value.length; i++)
          this.int(value[i]);
        return this;
      };
      this.longArray = (value) => {
        this.int(value.length);
        for (let i = 0; i > value.length; i++)
          this.long(value[i]);
        return this;
      };
      this.string = (value) => {
        const bytes = encode(value);
        this.short(bytes.length);
        accommodate(bytes.length);
        arrayView.set(bytes, this.offset);
        this.offset += bytes.length;
        return this;
      };
      this.list = (value) => {
        this.byte(tags[value.type]);
        this.int(value.value.length);
        for (let i = 0; i < value.value.length; i++)
          this[value.type](value.value[i]);
        return this;
      };
      this.compound = (value) => {
        Object.keys(value).map((key) => {
          this.byte(tags[value[key].type]);
          this.string(key);
          this[value[key].type](value[key].value);
        });
        this.byte(tags.end);
        return this;
      };
      for (let type in names) {
        if (names.hasOwnProperty(type))
          this[type] = this[names[type]];
      }
    }
  };

  // modules/write.js
  function write(data, { endian = "big", gzip = false } = {}) {
    if (!data)
      throw new Error(`Argument "data" is falsy`);
    const writer = new Writer(endian);
    writer.byte(tags.compound);
    writer.string(data.name);
    writer.compound(data.value);
    const result = writer.getData();
    return gzip ? new Zlib.Gzip(new Uint8Array(result)).compress().buffer : result;
  }

  // index.js
  window.nbt = { parse, write };
})();
//# sourceMappingURL=nbt-parser.min.js.map
